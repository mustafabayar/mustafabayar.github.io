<!doctype html><html lang=en><head><title>Dynamic Task Scheduling with Spring</title>
<meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="ie=edge"><link rel=stylesheet href=/application.ad1ee446d7262d3004a22442f08f5c2c6f9f593198211691d8ef45591a919d9f.css integrity="sha256-rR7kRtcmLTAEoiRC8I9cLG+fWTGYIRaR2O9FWRqRnZ8="><link rel=icon type=image/png href=/images/site/favicon_huc47b133053d6af9bc1f816c993f3c08a_29212_42x0_resize_box_3.png><meta property="og:title" content="Dynamic Task Scheduling with Spring"><meta property="og:description" content="How to create custom scheduler in Spring"><meta property="og:type" content="article"><meta property="og:url" content="https://mustafabayar.github.io/posts/dynamic-scheduling-spring/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-09-08T08:06:25+06:00"><meta property="article:modified_time" content="2018-09-08T08:06:25+06:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Dynamic Task Scheduling with Spring"><meta name=twitter:description content="How to create custom scheduler in Spring"><meta name=description content="How to create custom scheduler in Spring"><script>theme=localStorage.getItem("darkmode:color-scheme")||"system",theme=="system"&&(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?theme="dark":theme="light"),document.documentElement.setAttribute("data-theme",theme)</script></head><body class="type-posts kind-page" data-spy=scroll data-target=#TableOfContents data-offset=80><div class="container-fluid bg-secondary wrapper"><nav class="navbar navbar-expand-xl top-navbar shadow" id=top-navbar><div class=container><button class="navbar-toggler navbar-light" id=sidebar-toggler type=button>
<i data-feather=sidebar></i>
</button>
<a class=navbar-brand href=/><img src=/images/site/main-logo_huc47b133053d6af9bc1f816c993f3c08a_29212_42x0_resize_box_3.png id=logo alt=Logo>
Mustafa Bayar</a>
<button class="navbar-toggler navbar-light" id=navbar-toggler type=button data-toggle=collapse data-target=#top-nav-items aria-label=menu>
<i data-feather=menu></i></button><div class="collapse navbar-collapse dynamic-navbar" id=top-nav-items><ul class="nav navbar-nav ml-auto"><li class=nav-item><a class=nav-link href=/#home>Home</a></li><li class=nav-item><a class=nav-link href=/#about>About</a></li><li class=nav-item><a class=nav-link href=/#experiences>Experiences</a></li><li class=nav-item><a class=nav-link href=/#education>Education</a></li><div id=top-navbar-divider></div><li class=nav-item><a class=nav-link id=blog-link href=/posts>Posts</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=themeSelector role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false><img id=navbar-theme-icon-svg class=theme-icon src=/icons/moon-svgrepo-com.svg width=20 alt="Dark Theme"></a><div id=themeMenu class="dropdown-menu dropdown-menu-icons-only" aria-labelledby=themeSelector><a class="dropdown-item nav-link" href=# data-scheme=light><img class=theme-icon src=/icons/sun-svgrepo-com.svg width=20 alt="Light Theme">
</a><a class="dropdown-item nav-link" href=# data-scheme=dark><img class=theme-icon src=/icons/moon-svgrepo-com.svg width=20 alt="Dark Theme">
</a><a class="dropdown-item nav-link" href=# data-scheme=system><img class=theme-icon src=/icons/computer-svgrepo-com.svg width=20 alt="System Theme"></a></div></li></ul></div></div><img src=/images/site/main-logo_huc47b133053d6af9bc1f816c993f3c08a_29212_42x0_resize_box_3.png class=d-none id=main-logo alt=Logo>
<img src=/images/site/inverted-logo_huc47b133053d6af9bc1f816c993f3c08a_29212_42x0_resize_box_3.png class=d-none id=inverted-logo alt="Inverted Logo"></nav><section class=sidebar-section id=sidebar-section><div class=sidebar-holder><div class=sidebar id=sidebar><form class=mx-auto method=get action=/search><input type=text name=keyword placeholder=Search data-search id=search-box></form><div class=sidebar-tree><ul class=tree id=tree><li id=list-heading><a href=/posts/ data-filter=all>Posts</a></li><div class=subtree><li><a class="active list-link" href=/posts/dynamic-scheduling-spring/ title="Dynamic Task Scheduling">Dynamic Task Scheduling</a></li></div></ul></div></div></div></section><section class=content-section id=content-section><div class=content><div class="container p-0 read-area"><div class="hero-area col-sm-12" id=hero-area style=background-image:url(/posts/dynamic-scheduling-spring/hero.svg)></div><div class=page-content><div class="author-profile ml-auto align-self-lg-center"><img class=rounded-circle src=/images/author/me_hu87aa4187cc05746242e182f0b74e9f02_234485_120x120_fit_q75_box.jpg alt="Author Image"><h5 class=author-name>Mustafa Bayar</h5><p class=text-muted>Saturday, September 8, 2018 | 8 minutes</p></div><div class=title><h1>Dynamic Task Scheduling with Spring</h1></div><div class=tags><ul style=padding-left:0><li class=rounded><a href=/tags/java/ class="btn btn-sm btn-info">Java</a></li><li class=rounded><a href=/tags/spring/ class="btn btn-sm btn-info">Spring</a></li></ul></div><div class=post-content id=post-content><h3 id=summary>Summary</h3><p>Spring makes it very easy to schedule a job to run periodically. All we need to do is to put <strong><a href=https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/scheduling/annotation/Scheduled.html target=_blank rel=noopener>@Scheduled</a></strong> annotation above the method and provide the necessary parameters such as fixedRate or cron expression. But when it comes to change this fixedRate on the fly, <code>@Scheduled</code> annotation is not enough. Ultimately, what I wanted to do was periodically load my configuration table from a database. But the <code>fixedRate</code> which indicates how frequently I will load this table is also stored in the very same database. So what I wanted to do was reading this value from a database and schedule the task according to it. Whenever the value changes, the next execution time should change with it too.
Before going into next step, I also created a repository for all the code in this tutorial to show how this scheduling works. You can find the example code in <a href=https://github.com/mustafabayar/java-dynamic-scheduling-tutorial target=_blank rel=noopener>my Github page</a>
Also at the end I will add an alternative way for scheduling with exact date and a way to start the scheduler from external service (like controller).
Please check the above repository for various scheduling examples.</p><h3 id=loading-the-value-from-properties-file>Loading the value from properties file</h3><p>First of all, in <code>@Scheduled</code> annotation you can only use constant values. To use Spring’s Scheduler, you need to put <code>@EnableScheduling</code> annotation above any of your class. I prefer my Main Application class for that purpose, but any of the classes should work. You can retrieve the value for this scheduler from your properties file. Such as;</p><pre tabindex=0><code>@Scheduled(fixedRateString = &#34;${scheduler.configurationLoadRate}&#34;)
public void loadConfigurations() {
...
}
</code></pre><p><code>scheduler.configurationLoadRate</code> is the property I have defined in my property file.</p><pre tabindex=0><code>scheduler.configurationLoadRate=3600000
</code></pre><p>But this brings another problem. Whenever I want to change this value, I have to restart the application, which is not very convenient. I wanted to inject a value from a database but we can’t store a value in a variable and use in the annotation because it only accepts constant values. Later I have discovered a way to use values from a database;</p><h3 id=loading-the-value-from-a-database>Loading the value from a database</h3><p>First I am creating a bean which retrieves data from the database whenever it is called. And then giving this bean to my <code>@Scheduled</code> annotation using <strong><a href=https://docs.spring.io/spring-framework/reference/core/expressions.html target=_blank rel=noopener>SpEL</a></strong>, so-called <strong>Spring Expression Language</strong>.</p><pre tabindex=0><code>@Bean
public String getConfigRefreshValue() {
   return configRepository.findOne(Constants.CONFIG_KEY_REFRESH_RATE).getConfigValue();
}
.
.
.
@Scheduled(fixedRateString = &#34;#{@getConfigRefreshValue}&#34;)
public void loadConfigurations() {
...
}
</code></pre><p>This works like a charm but Houston, we have a problem. This <code>@Scheduled</code> annotation only looks at the fixedRate once and never looks at it again. So even if the value changes, it doesn’t care. I mean if all you want is to retrieve this data from a database, you can go with this solution. But I realised that dynamic task scheduling with Spring can not be done by <code>@Scheduled</code> annotation. So after some search I decided to create my own Scheduler Service that implements <strong>SchedulerConfigurer</strong> which successfully changed the rate whenever the data changes. You can find the solution below.</p><pre tabindex=0><code>import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.scheduling.TaskScheduler;
import org.springframework.scheduling.Trigger;
import org.springframework.scheduling.TriggerContext;
import org.springframework.scheduling.annotation.SchedulingConfigurer;
import org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler;
import org.springframework.scheduling.config.ScheduledTaskRegistrar;
import org.springframework.stereotype.Service;

@Service
public class SchedulerService implements SchedulingConfigurer {

    @Autowired
    ConfigurationService    configurationService;
   
    @Bean
    public TaskScheduler poolScheduler() {
        ThreadPoolTaskScheduler scheduler = new ThreadPoolTaskScheduler();
        scheduler.setThreadNamePrefix(&#34;ThreadPoolTaskScheduler&#34;);
        scheduler.setPoolSize(1);
        scheduler.initialize();
        return scheduler;
    }

    @Override
    public void configureTasks(ScheduledTaskRegistrar taskRegistrar) {
        taskRegistrar.setScheduler(poolScheduler());
        taskRegistrar.addTriggerTask(new Runnable() {
            @Override
            public void run() {
                // Do not put @Scheduled annotation above this method, we don&#39;t need it anymore.
                configurationService.loadConfigurations();
            }
        }, new Trigger() {
            @Override
            public Date nextExecutionTime(TriggerContext triggerContext) {
                Calendar nextExecutionTime = new GregorianCalendar();
                Date lastActualExecutionTime = triggerContext.lastActualExecutionTime();
                nextExecutionTime.setTime(lastActualExecutionTime != null ? lastActualExecutionTime : new Date());
                nextExecutionTime.add(Calendar.MILLISECOND, Integer.parseInt(configurationService.getConfiguration(Constants.CONFIG_KEY_REFRESH_RATE_CONFIG).getConfigValue()));
                return nextExecutionTime.getTime();
            }
        });
    }

}
</code></pre><p>We can also write the same function with lambda expressions which will be more compact;</p><pre tabindex=0><code>    @Override
    public void configureTasks(ScheduledTaskRegistrar taskRegistrar) {
        taskRegistrar.setScheduler(poolScheduler());
        taskRegistrar.addTriggerTask(() -&gt; configurationService.loadConfigurations(), t -&gt; {
            Calendar nextExecutionTime = new GregorianCalendar();
            Date lastActualExecutionTime = t.lastActualExecutionTime();
            nextExecutionTime.setTime(lastActualExecutionTime != null ? lastActualExecutionTime : new Date());
            nextExecutionTime.add(Calendar.MILLISECOND,
                    Integer.parseInt(configurationService.getConfiguration(Constants.CONFIG_KEY_REFRESH_RATE_CONFIG).getConfigValue()));
            return nextExecutionTime.getTime();
        });
    }
</code></pre><p>I tried to add cancelling and re-activating feature to the Scheduler. With little tweak to above code we can achieve it, but I am not sure if it is the optimal solution or not, so use it at your own risk:</p><pre tabindex=0><code>package com.mbcoder.scheduler.service;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.scheduling.TaskScheduler;
import org.springframework.scheduling.annotation.SchedulingConfigurer;
import org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler;
import org.springframework.scheduling.config.ScheduledTaskRegistrar;
import org.springframework.stereotype.Service;

import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.concurrent.ScheduledFuture;

/**
 * Alternative version for DynamicScheduler
 * This one should support everything the basic dynamic scheduler does,
 * and on top of it, you can cancel and re-activate the scheduler.
 */
@Service
public class CancellableScheduler implements SchedulingConfigurer {

    private static Logger LOGGER = LoggerFactory.getLogger(DynamicScheduler.class);

    ScheduledTaskRegistrar scheduledTaskRegistrar;

    ScheduledFuture future;

    @Bean
    public TaskScheduler poolScheduler() {
        ThreadPoolTaskScheduler scheduler = new ThreadPoolTaskScheduler();
        scheduler.setThreadNamePrefix(&#34;ThreadPoolTaskScheduler&#34;);
        scheduler.setPoolSize(1);
        scheduler.initialize();
        return scheduler;
    }

    // We can have multiple tasks inside the same registrar as we can see below.
    @Override
    public void configureTasks(ScheduledTaskRegistrar taskRegistrar) {
        if (scheduledTaskRegistrar == null) {
            scheduledTaskRegistrar = taskRegistrar;
        }
        if (taskRegistrar.getScheduler() == null) {
            taskRegistrar.setScheduler(poolScheduler());
        }

        future = taskRegistrar.getScheduler().schedule(() -&gt; scheduleFixed(), t -&gt; {
            Calendar nextExecutionTime = new GregorianCalendar();
            Date lastActualExecutionTime = t.lastActualExecutionTime();
            nextExecutionTime.setTime(lastActualExecutionTime != null ? lastActualExecutionTime : new Date());
            nextExecutionTime.add(Calendar.SECOND, 7);
            return nextExecutionTime.getTime();
        });

        // or cron way
        taskRegistrar.addTriggerTask(() -&gt; scheduleCron(repo.findById(&#34;next_exec_time&#34;).get().getConfigValue()), t -&gt; {
            CronTrigger crontrigger = new CronTrigger(repo.findById(&#34;next_exec_time&#34;).get().getConfigValue());
            return crontrigger.nextExecutionTime(t);
        });
    }

    public void scheduleFixed() {
        LOGGER.info(&#34;scheduleFixed: Next execution time of this will always be 5 seconds&#34;);
    }

    public void scheduleCron(String cron) {
        LOGGER.info(&#34;scheduleCron: Next execution time of this taken from cron expression -&gt; {}&#34;, cron);
    }

    /**
     * @param mayInterruptIfRunning {@code true} if the thread executing this task
     * should be interrupted; otherwise, in-progress tasks are allowed to complete
     */
    public void cancelTasks(boolean mayInterruptIfRunning) {
        LOGGER.info(&#34;Cancelling all tasks&#34;);
        future.cancel(mayInterruptIfRunning); // set to false if you want the running task to be completed first.
    }

    public void activateScheduler() {
        LOGGER.info(&#34;Re-Activating Scheduler&#34;);
        configureTasks(scheduledTaskRegistrar);
    }

}
</code></pre><p>We don’t have to keep the reference to future, we can add and remove jobs from external service like;</p><pre tabindex=0><code>package com.mbcoder.scheduler.service;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.scheduling.TaskScheduler;
import org.springframework.scheduling.annotation.SchedulingConfigurer;
import org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler;
import org.springframework.scheduling.config.ScheduledTaskRegistrar;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.concurrent.ScheduledFuture;

@Service
public class ExternalScheduler implements SchedulingConfigurer {

    private static Logger LOGGER = LoggerFactory.getLogger(ExternalScheduler.class);

    ScheduledTaskRegistrar scheduledTaskRegistrar;

    Map&lt;String, ScheduledFuture&gt; futureMap = new HashMap&lt;&gt;();

    @Bean
    public TaskScheduler poolScheduler() {
        ThreadPoolTaskScheduler scheduler = new ThreadPoolTaskScheduler();
        scheduler.setThreadNamePrefix(&#34;ThreadPoolTaskScheduler&#34;);
        scheduler.setPoolSize(1);
        scheduler.initialize();
        return scheduler;
    }

    // Initially scheduler has no job
    @Override
    public void configureTasks(ScheduledTaskRegistrar taskRegistrar) {
        if (scheduledTaskRegistrar == null) {
            scheduledTaskRegistrar = taskRegistrar;
        }
        if (taskRegistrar.getScheduler() == null) {
            taskRegistrar.setScheduler(poolScheduler());
        }
    }

    public boolean addJob(String jobName) {
        if (futureMap.containsKey(jobName)) {
            return false;
        }

        ScheduledFuture future = scheduledTaskRegistrar.getScheduler().schedule(() -&gt; methodToBeExecuted(), t -&gt; {
            Calendar nextExecutionTime = new GregorianCalendar();
            Date lastActualExecutionTime = t.lastActualExecutionTime();
            nextExecutionTime.setTime(lastActualExecutionTime != null ? lastActualExecutionTime : new Date());
            nextExecutionTime.add(Calendar.SECOND, 5);
            return nextExecutionTime.getTime();
        });

        configureTasks(scheduledTaskRegistrar);
        futureMap.put(jobName, future);
        return true;
    }

    public boolean removeJob(String name) {
        if (!futureMap.containsKey(name)) {
            return false;
        }
        ScheduledFuture future = futureMap.get(name);
        future.cancel(true);
        futureMap.remove(name);
        return true;
    }

    public void methodToBeExecuted() {
        LOGGER.info(&#34;methodToBeExecuted: Next execution time of this will always be 5 seconds&#34;);
    }

}
</code></pre><p>Since some of you asked for the code of my ConfigurationService, I decided to post the code here. Below you can find the implementation of Configuration model, ConfigRepository, ConfigurationService and Constants:</p><pre tabindex=0><code>@Entity
public class Configuration {

    @Id
    @Size(max = 128)
    String  configKey;

    @Size(max = 512)
    @NotNull
    String  configValue;

    public Configuration() {
    }

    public Configuration(String configKey, String configValue) {
        this.configKey = configKey;
        this.configValue = configValue;
    }

    public String getConfigKey() {
        return configKey;
    }

    public void setConfigKey(String configKey) {
        this.configKey = configKey;
    }

    public String getConfigValue() {
        return configValue;
    }

    public void setConfigValue(String configValue) {
        this.configValue = configValue;
    }

}
</code></pre><pre tabindex=0><code>public interface ConfigRepository extends JpaRepository&lt;Configuration, String&gt; {

}
</code></pre><pre tabindex=0><code>/**
 * ConfigurationService is responsible for loading and checking configuration parameters.
 *
 * @author mbcoder
 *
 */
@Service
public class ConfigurationService {

    private static final Logger         LOGGER  = LoggerFactory.getLogger(ConfigurationService.class);

    ConfigRepository                    configRepository;

    private Map&lt;String, Configuration&gt;  configurationList;

    private List&lt;String&gt;                mandatoryConfigs;

    @Autowired
    public ConfigurationService(ConfigRepository configRepository) {
        this.configRepository = configRepository;
        this.configurationList = new ConcurrentHashMap&lt;&gt;();
        this.mandatoryConfigs = new ArrayList&lt;&gt;();
        this.mandatoryConfigs.add(Constants.CONFIG_KEY_REFRESH_RATE_CONFIG);
        this.mandatoryConfigs.add(Constants.CONFIG_KEY_REFRESH_RATE_METRIC);
        this.mandatoryConfigs.add(Constants.CONFIG_KEY_REFRESH_RATE_TOKEN);
        this.mandatoryConfigs.add(Constants.CONFIG_KEY_REFRESH_RATE_USER);
    }

    /**
     * Loads configuration parameters from Database
     */
    @PostConstruct
    public void loadConfigurations() {
        LOGGER.debug(&#34;Scheduled Event: Configuration table loaded/updated from database&#34;);
        StringBuilder sb = new StringBuilder();
        sb.append(&#34;Configuration Parameters:&#34;);
        List&lt;Configuration&gt; configs = configRepository.findAll();
        for (Configuration configuration : configs) {
            sb.append(&#34;\n&#34; + configuration.getConfigKey() + &#34;:&#34; + configuration.getConfigValue());
            this.configurationList.put(configuration.getConfigKey(), configuration);
        }
        LOGGER.debug(sb.toString());

        checkMandatoryConfigurations();
    }

    public Configuration getConfiguration(String key) {
        return configurationList.get(key);
    }

    /**
     * Checks if the mandatory parameters are exists in Database
     */
    public void checkMandatoryConfigurations() {
        for (String mandatoryConfig : mandatoryConfigs) {
            boolean exists = false;
            for (Map.Entry&lt;String, Configuration&gt; pair : configurationList.entrySet()) {
                if (pair.getKey().equalsIgnoreCase(mandatoryConfig) &amp;&amp; !pair.getValue().getConfigValue().isEmpty()) {
                    exists = true;
                }
            }
            if (!exists) {
                String errorLog = String.format(&#34;A mandatory Configuration parameter is not found in DB: %s&#34;, mandatoryConfig);
                LOGGER.error(errorLog);
            }
        }

    }
}
</code></pre><p>Alternatively we can also do the scheduling by giving the exact date, in that case we don’t need to know previous execution time. For example:</p><pre tabindex=0><code>// startDate and endDate are only calendar date and time indicates at which hour/minute of the day.
public void scheduleAt(LocalDate startDate, LocalDate endDate, LocalTime time) {
    LocalDate now = LocalDate.now();
    if (now.isBefore(endDate)) {
        if (now.isBefore(startDate)) {
            now = startDate;
        }
        LocalDateTime current = now.atTime(time);
        ZoneId zone = ZoneId.of(&#34;Europe/Berlin&#34;);
        ZoneOffset zoneOffSet = zone.getRules().getOffset(current);
        Instant nextRunTime = current.toInstant(zoneOffSet);
        poolScheduler().schedule(() -&gt; realMethod(), nextRunTime);
    }
}

public void realMethod() {
    // This is your real code to be scheduled
}
</code></pre><h3 id=final-words>Final Words</h3><p>You can expand this solution to run this every day for example, and you can load start/end dates from database.</p><p>Don’t forget to check my <a href=https://github.com/mustafabayar/java-dynamic-scheduling-tutorial target=_blank rel=noopener>Github repository</a> to have a better understanding of how this code looks like, and also if this helped you, feel free to give the repository a star 🙂</p><p>All this solutions are my own interpretation. For production level usage, you may want to use a scheduling library such as Jesque.</p></div><div class="row pl-3 pr-3"><div class="col-md-6 share-buttons"><strong>Share on:</strong>
<a class="btn icon-button bg-facebook" href="https://www.facebook.com/sharer.php?u=https%3a%2f%2fmustafabayar.github.io%2fposts%2fdynamic-scheduling-spring%2f" target=_blank><i class="fab fa-facebook"></i>
</a><a class="btn icon-button bg-twitter" href="https://twitter.com/share?url=https%3a%2f%2fmustafabayar.github.io%2fposts%2fdynamic-scheduling-spring%2f&text=Dynamic%20Task%20Scheduling%20with%20Spring&via=Mustafa%20Bayar" target=_blank><i class="fab fa-twitter"></i>
</a><a class="btn icon-button bg-reddit" href="https://reddit.com/submit?url=https%3a%2f%2fmustafabayar.github.io%2fposts%2fdynamic-scheduling-spring%2f&title=Dynamic%20Task%20Scheduling%20with%20Spring" target=_blank><i class="fab fa-reddit"></i>
</a><a class="btn icon-button bg-linkedin" href="https://www.linkedin.com/shareArticle?url=https%3a%2f%2fmustafabayar.github.io%2fposts%2fdynamic-scheduling-spring%2f&title=Dynamic%20Task%20Scheduling%20with%20Spring" target=_blank><i class="fab fa-linkedin"></i>
</a><a class="btn icon-button bg-whatsapp" href="https://api.whatsapp.com/send?text=Dynamic%20Task%20Scheduling%20with%20Spring https%3a%2f%2fmustafabayar.github.io%2fposts%2fdynamic-scheduling-spring%2f" target=_blank><i class="fab fa-whatsapp"></i>
</a><a class="btn icon-button" href="mailto:?subject=Dynamic%20Task%20Scheduling%20with%20Spring&body=https%3a%2f%2fmustafabayar.github.io%2fposts%2fdynamic-scheduling-spring%2f" target=_blank><i class="fas fa-envelope-open-text"></i></a></div><div class="col-md-6 btn-improve-page"><a href=https://github.com/mustafabayar/mustafabayar.github.io/edit/main/content/posts/dynamic-scheduling-spring/index.md title="Improve this page" target=_blank rel=noopener><i class="fas fa-code-branch"></i>
Improve this page</a></div></div><hr><div class="row next-prev-navigator"></div><hr></div></div></div><a id=scroll-to-top class=btn data-toggle=tooltip data-placement=left title="Scroll to top"><i class="fas fa-chevron-circle-up"></i></a></section><section class=toc-section id=toc-section><div class=toc-holder><h5 class="text-center pl-3">Table of Contents</h5><hr><div class=toc><nav id=TableOfContents><ul><li><ul><li><a href=#summary>Summary</a></li><li><a href=#loading-the-value-from-properties-file>Loading the value from properties file</a></li><li><a href=#loading-the-value-from-a-database>Loading the value from a database</a></li><li><a href=#final-words>Final Words</a></li></ul></li></ul></nav></div></div></section></div><footer id=footer class="container-fluid text-center align-content-center footer pb-2"><div class="container pt-5"><div class="row text-left"></div></div><hr><div class=container><div class="row text-left"><div class=col-md-4><a id=theme href=https://github.com/hugo-toha/toha target=_blank rel=noopener><img src=/images/theme-logo_hu8376fd15465fef26ffe66b6bcf0ca686_13669_32x0_resize_box_3.png alt="Toha Theme Logo">
Toha</a></div><div class="col-md-4 text-center">© 2024 Copyright.</div><div class="col-md-4 text-right"><a id=hugo href=https://gohugo.io/ target=_blank rel=noopener>Powered by
<img src=/images/hugo-logo.svg alt="Hugo Logo" height=18></a></div></div></div></footer><script src=/application.578ca6085de1662c9955283726de62b5e5a8d3348791733baba1cdee1d135f90.js integrity="sha256-V4ymCF3hZiyZVSg3Jt5iteWo0zSHkXM7q6HN7h0TX5A=" defer></script></body></html>