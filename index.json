[{"categories":["Basic"],"contents":"Summary Spring makes it very easy to schedule a job to run periodically. All we need to do is to put @Scheduled annotation above the method and provide the necessary parameters such as fixedRate or cron expression. But when it comes to change this fixedRate on the fly, @Scheduled annotation is not enough. Ultimately, what I wanted to do was periodically load my configuration table from a database. But the fixedRate which indicates how frequently I will load this table is also stored in the very same database. So what I wanted to do was reading this value from a database and schedule the task according to it. Whenever the value changes, the next execution time should change with it too. Before going into next step, I also created a repository for all the code in this tutorial to show how this scheduling works. You can find the example code in my Github page Also at the end I will add an alternative way for scheduling with exact date and a way to start the scheduler from external service (like controller). Please check the above repository for various scheduling examples.\nLoading the value from properties file First of all, in @Scheduled annotation you can only use constant values. To use Springâ€™s Scheduler, you need to put @EnableScheduling annotation above any of your class. I prefer my Main Application class for that purpose, but any of the classes should work. You can retrieve the value for this scheduler from your properties file. Such as;\n@Scheduled(fixedRateString = \u0026#34;${scheduler.configurationLoadRate}\u0026#34;) public void loadConfigurations() { ... } scheduler.configurationLoadRate is the property I have defined in my property file.\nscheduler.configurationLoadRate=3600000 But this brings another problem. Whenever I want to change this value, I have to restart the application, which is not very convenient. I wanted to inject a value from a database but we canâ€™t store a value in a variable and use in the annotation because it only accepts constant values. Later I have discovered a way to use values from a database;\nLoading the value from a database First I am creating a bean which retrieves data from the database whenever it is called. And then giving this bean to my @Scheduled annotation using SpEL, so-called Spring Expression Language.\n@Bean public String getConfigRefreshValue() { return configRepository.findOne(Constants.CONFIG_KEY_REFRESH_RATE).getConfigValue(); } . . . @Scheduled(fixedRateString = \u0026#34;#{@getConfigRefreshValue}\u0026#34;) public void loadConfigurations() { ... } This works like a charm but Houston, we have a problem. This @Scheduled annotation only looks at the fixedRate once and never looks at it again. So even if the value changes, it doesnâ€™t care. I mean if all you want is to retrieve this data from a database, you can go with this solution. But I realised that dynamic task scheduling with Spring can not be done by @Scheduled annotation. So after some search I decided to create my own Scheduler Service that implements SchedulerConfigurer which successfully changed the rate whenever the data changes. You can find the solution below.\nimport java.util.Calendar; import java.util.Date; import java.util.GregorianCalendar; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Bean; import org.springframework.scheduling.TaskScheduler; import org.springframework.scheduling.Trigger; import org.springframework.scheduling.TriggerContext; import org.springframework.scheduling.annotation.SchedulingConfigurer; import org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler; import org.springframework.scheduling.config.ScheduledTaskRegistrar; import org.springframework.stereotype.Service; @Service public class SchedulerService implements SchedulingConfigurer { @Autowired ConfigurationService configurationService; @Bean public TaskScheduler poolScheduler() { ThreadPoolTaskScheduler scheduler = new ThreadPoolTaskScheduler(); scheduler.setThreadNamePrefix(\u0026#34;ThreadPoolTaskScheduler\u0026#34;); scheduler.setPoolSize(1); scheduler.initialize(); return scheduler; } @Override public void configureTasks(ScheduledTaskRegistrar taskRegistrar) { taskRegistrar.setScheduler(poolScheduler()); taskRegistrar.addTriggerTask(new Runnable() { @Override public void run() { // Do not put @Scheduled annotation above this method, we don\u0026#39;t need it anymore. configurationService.loadConfigurations(); } }, new Trigger() { @Override public Date nextExecutionTime(TriggerContext triggerContext) { Calendar nextExecutionTime = new GregorianCalendar(); Date lastActualExecutionTime = triggerContext.lastActualExecutionTime(); nextExecutionTime.setTime(lastActualExecutionTime != null ? lastActualExecutionTime : new Date()); nextExecutionTime.add(Calendar.MILLISECOND, Integer.parseInt(configurationService.getConfiguration(Constants.CONFIG_KEY_REFRESH_RATE_CONFIG).getConfigValue())); return nextExecutionTime.getTime(); } }); } } We can also write the same function with lambda expressions which will be more compact;\n@Override public void configureTasks(ScheduledTaskRegistrar taskRegistrar) { taskRegistrar.setScheduler(poolScheduler()); taskRegistrar.addTriggerTask(() -\u0026gt; configurationService.loadConfigurations(), t -\u0026gt; { Calendar nextExecutionTime = new GregorianCalendar(); Date lastActualExecutionTime = t.lastActualExecutionTime(); nextExecutionTime.setTime(lastActualExecutionTime != null ? lastActualExecutionTime : new Date()); nextExecutionTime.add(Calendar.MILLISECOND, Integer.parseInt(configurationService.getConfiguration(Constants.CONFIG_KEY_REFRESH_RATE_CONFIG).getConfigValue())); return nextExecutionTime.getTime(); }); } I tried to add cancelling and re-activating feature to the Scheduler. With little tweak to above code we can achieve it, but I am not sure if it is the optimal solution or not, so use it at your own risk:\npackage com.mbcoder.scheduler.service; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.context.annotation.Bean; import org.springframework.scheduling.TaskScheduler; import org.springframework.scheduling.annotation.SchedulingConfigurer; import org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler; import org.springframework.scheduling.config.ScheduledTaskRegistrar; import org.springframework.stereotype.Service; import java.util.Calendar; import java.util.Date; import java.util.GregorianCalendar; import java.util.concurrent.ScheduledFuture; /** * Alternative version for DynamicScheduler * This one should support everything the basic dynamic scheduler does, * and on top of it, you can cancel and re-activate the scheduler. */ @Service public class CancellableScheduler implements SchedulingConfigurer { private static Logger LOGGER = LoggerFactory.getLogger(DynamicScheduler.class); ScheduledTaskRegistrar scheduledTaskRegistrar; ScheduledFuture future; @Bean public TaskScheduler poolScheduler() { ThreadPoolTaskScheduler scheduler = new ThreadPoolTaskScheduler(); scheduler.setThreadNamePrefix(\u0026#34;ThreadPoolTaskScheduler\u0026#34;); scheduler.setPoolSize(1); scheduler.initialize(); return scheduler; } // We can have multiple tasks inside the same registrar as we can see below. @Override public void configureTasks(ScheduledTaskRegistrar taskRegistrar) { if (scheduledTaskRegistrar == null) { scheduledTaskRegistrar = taskRegistrar; } if (taskRegistrar.getScheduler() == null) { taskRegistrar.setScheduler(poolScheduler()); } future = taskRegistrar.getScheduler().schedule(() -\u0026gt; scheduleFixed(), t -\u0026gt; { Calendar nextExecutionTime = new GregorianCalendar(); Date lastActualExecutionTime = t.lastActualExecutionTime(); nextExecutionTime.setTime(lastActualExecutionTime != null ? lastActualExecutionTime : new Date()); nextExecutionTime.add(Calendar.SECOND, 7); return nextExecutionTime.getTime(); }); // or cron way taskRegistrar.addTriggerTask(() -\u0026gt; scheduleCron(repo.findById(\u0026#34;next_exec_time\u0026#34;).get().getConfigValue()), t -\u0026gt; { CronTrigger crontrigger = new CronTrigger(repo.findById(\u0026#34;next_exec_time\u0026#34;).get().getConfigValue()); return crontrigger.nextExecutionTime(t); }); } public void scheduleFixed() { LOGGER.info(\u0026#34;scheduleFixed: Next execution time of this will always be 5 seconds\u0026#34;); } public void scheduleCron(String cron) { LOGGER.info(\u0026#34;scheduleCron: Next execution time of this taken from cron expression -\u0026gt; {}\u0026#34;, cron); } /** * @param mayInterruptIfRunning {@code true} if the thread executing this task * should be interrupted; otherwise, in-progress tasks are allowed to complete */ public void cancelTasks(boolean mayInterruptIfRunning) { LOGGER.info(\u0026#34;Cancelling all tasks\u0026#34;); future.cancel(mayInterruptIfRunning); // set to false if you want the running task to be completed first. } public void activateScheduler() { LOGGER.info(\u0026#34;Re-Activating Scheduler\u0026#34;); configureTasks(scheduledTaskRegistrar); } } We donâ€™t have to keep the reference to future, we can add and remove jobs from external service like;\npackage com.mbcoder.scheduler.service; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.context.annotation.Bean; import org.springframework.scheduling.TaskScheduler; import org.springframework.scheduling.annotation.SchedulingConfigurer; import org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler; import org.springframework.scheduling.config.ScheduledTaskRegistrar; import org.springframework.stereotype.Service; import java.util.*; import java.util.concurrent.ScheduledFuture; @Service public class ExternalScheduler implements SchedulingConfigurer { private static Logger LOGGER = LoggerFactory.getLogger(ExternalScheduler.class); ScheduledTaskRegistrar scheduledTaskRegistrar; Map\u0026lt;String, ScheduledFuture\u0026gt; futureMap = new HashMap\u0026lt;\u0026gt;(); @Bean public TaskScheduler poolScheduler() { ThreadPoolTaskScheduler scheduler = new ThreadPoolTaskScheduler(); scheduler.setThreadNamePrefix(\u0026#34;ThreadPoolTaskScheduler\u0026#34;); scheduler.setPoolSize(1); scheduler.initialize(); return scheduler; } // Initially scheduler has no job @Override public void configureTasks(ScheduledTaskRegistrar taskRegistrar) { if (scheduledTaskRegistrar == null) { scheduledTaskRegistrar = taskRegistrar; } if (taskRegistrar.getScheduler() == null) { taskRegistrar.setScheduler(poolScheduler()); } } public boolean addJob(String jobName) { if (futureMap.containsKey(jobName)) { return false; } ScheduledFuture future = scheduledTaskRegistrar.getScheduler().schedule(() -\u0026gt; methodToBeExecuted(), t -\u0026gt; { Calendar nextExecutionTime = new GregorianCalendar(); Date lastActualExecutionTime = t.lastActualExecutionTime(); nextExecutionTime.setTime(lastActualExecutionTime != null ? lastActualExecutionTime : new Date()); nextExecutionTime.add(Calendar.SECOND, 5); return nextExecutionTime.getTime(); }); configureTasks(scheduledTaskRegistrar); futureMap.put(jobName, future); return true; } public boolean removeJob(String name) { if (!futureMap.containsKey(name)) { return false; } ScheduledFuture future = futureMap.get(name); future.cancel(true); futureMap.remove(name); return true; } public void methodToBeExecuted() { LOGGER.info(\u0026#34;methodToBeExecuted: Next execution time of this will always be 5 seconds\u0026#34;); } } Since some of you asked for the code of my ConfigurationService, I decided to post the code here. Below you can find the implementation of Configuration model, ConfigRepository, ConfigurationService and Constants:\n@Entity public class Configuration { @Id @Size(max = 128) String configKey; @Size(max = 512) @NotNull String configValue; public Configuration() { } public Configuration(String configKey, String configValue) { this.configKey = configKey; this.configValue = configValue; } public String getConfigKey() { return configKey; } public void setConfigKey(String configKey) { this.configKey = configKey; } public String getConfigValue() { return configValue; } public void setConfigValue(String configValue) { this.configValue = configValue; } } public interface ConfigRepository extends JpaRepository\u0026lt;Configuration, String\u0026gt; { } /** * ConfigurationService is responsible for loading and checking configuration parameters. * * @author mbcoder * */ @Service public class ConfigurationService { private static final Logger LOGGER = LoggerFactory.getLogger(ConfigurationService.class); ConfigRepository configRepository; private Map\u0026lt;String, Configuration\u0026gt; configurationList; private List\u0026lt;String\u0026gt; mandatoryConfigs; @Autowired public ConfigurationService(ConfigRepository configRepository) { this.configRepository = configRepository; this.configurationList = new ConcurrentHashMap\u0026lt;\u0026gt;(); this.mandatoryConfigs = new ArrayList\u0026lt;\u0026gt;(); this.mandatoryConfigs.add(Constants.CONFIG_KEY_REFRESH_RATE_CONFIG); this.mandatoryConfigs.add(Constants.CONFIG_KEY_REFRESH_RATE_METRIC); this.mandatoryConfigs.add(Constants.CONFIG_KEY_REFRESH_RATE_TOKEN); this.mandatoryConfigs.add(Constants.CONFIG_KEY_REFRESH_RATE_USER); } /** * Loads configuration parameters from Database */ @PostConstruct public void loadConfigurations() { LOGGER.debug(\u0026#34;Scheduled Event: Configuration table loaded/updated from database\u0026#34;); StringBuilder sb = new StringBuilder(); sb.append(\u0026#34;Configuration Parameters:\u0026#34;); List\u0026lt;Configuration\u0026gt; configs = configRepository.findAll(); for (Configuration configuration : configs) { sb.append(\u0026#34;\\n\u0026#34; + configuration.getConfigKey() + \u0026#34;:\u0026#34; + configuration.getConfigValue()); this.configurationList.put(configuration.getConfigKey(), configuration); } LOGGER.debug(sb.toString()); checkMandatoryConfigurations(); } public Configuration getConfiguration(String key) { return configurationList.get(key); } /** * Checks if the mandatory parameters are exists in Database */ public void checkMandatoryConfigurations() { for (String mandatoryConfig : mandatoryConfigs) { boolean exists = false; for (Map.Entry\u0026lt;String, Configuration\u0026gt; pair : configurationList.entrySet()) { if (pair.getKey().equalsIgnoreCase(mandatoryConfig) \u0026amp;\u0026amp; !pair.getValue().getConfigValue().isEmpty()) { exists = true; } } if (!exists) { String errorLog = String.format(\u0026#34;A mandatory Configuration parameter is not found in DB: %s\u0026#34;, mandatoryConfig); LOGGER.error(errorLog); } } } } Alternatively we can also do the scheduling by giving the exact date, in that case we donâ€™t need to know previous execution time. For example:\n// startDate and endDate are only calendar date and time indicates at which hour/minute of the day. public void scheduleAt(LocalDate startDate, LocalDate endDate, LocalTime time) { LocalDate now = LocalDate.now(); if (now.isBefore(endDate)) { if (now.isBefore(startDate)) { now = startDate; } LocalDateTime current = now.atTime(time); ZoneId zone = ZoneId.of(\u0026#34;Europe/Berlin\u0026#34;); ZoneOffset zoneOffSet = zone.getRules().getOffset(current); Instant nextRunTime = current.toInstant(zoneOffSet); poolScheduler().schedule(() -\u0026gt; realMethod(), nextRunTime); } } public void realMethod() { // This is your real code to be scheduled } Final Words You can expand this solution to run this every day for example, and you can load start/end dates from database.\nDonâ€™t forget to check my Github repository to have a better understanding of how this code looks like, and also if this helped you, feel free to give the repository a star ðŸ™‚\nAll this solutions are my own interpretation. For production level usage, you may want to use a scheduling library such as Jesque.\n","date":"September 8, 2018","hero":"/posts/dynamic-scheduling-spring/hero.svg","permalink":"https://mustafabayar.github.io/posts/dynamic-scheduling-spring/","summary":"Summary Spring makes it very easy to schedule a job to run periodically. All we need to do is to put @Scheduled annotation above the method and provide the necessary parameters such as fixedRate or cron expression. But when it comes to change this fixedRate on the fly, @Scheduled annotation is not enough. Ultimately, what I wanted to do was periodically load my configuration table from a database. But the fixedRate which indicates how frequently I will load this table is also stored in the very same database.","tags":["Java","Spring"],"title":"Dynamic Task Scheduling with Spring"}]